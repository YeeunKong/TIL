## DP 문제 복습하기

최댓값, 최솟값 구하는 문제는 DP 문제 의심해 봐야한다. 

그 중에서도 아래의 조건을 만족한다면 DP로 푸는 것이 적절하다.

1) 작은 문제로 쪼개서 풀어야 되는 문제 + 단계마다의 최적 선택이 문제 전체의 최적 선택이 되는 문제
2) 결과를 계속 저장해나가고, 그것을 재활용해야 하는 문제(메모이제이션)


지금 생각하면 좀 바보같지만..? 내가 지금까지 DP 문제를 풀며 시행착오를 겪고 깨달은 점이 몇가지 있다.

첫 번째로, DP 문제를 풀 땐 단계마다 '최적의 선택'만을 저장해야 한다는 점이다

처음에는 메모이제이션을 사용하는 문제라고 해서 '저장'해놓은 데에만 신경을 썼었다. 그러나 모든 선택지를 저장해두면 바로 메모리 초과가 뜨게 될 것이다. 보통 리스트는 데이터를 입력받을 때 사용한 리스트, 혹은 거기에 1차원 리스트를 추가한 정도만 필요한 것 같다. 그리고 최적의 결과를 계산해서 단계마다 리스트에 저장해두고, 다음 단계에서 그것을 재활용하여 사용하는 것이다.

그래서 DP 문제를 풀다보면 아래와 같은 형태를 많이 볼 수 있다.

```python
for i in range(1, n):
    dp[i] = max(x, y)
```
- 배열에 단계마다의 결과를 저장해야 하고
- 이때 결과는 최적의 선택이어야 하므로, max() 혹은 min()을 자주 사용하게 된다.
- 그리고 보통 x, y에 들어갈 변수는 dp[i-1]을 사용하는 경우가 매우 많다. 이전 저장해 놓은 결과를 재활용하기 때문에!

두 번째로, 어떤 결과를 저장해나갈지를 잘 생각해야 한다는 점이다. 즉, 저장할 변수를 잘 정해야 한다. 


이는 첫 번째와 연결되는 부분이기도 한데, 문제에서 요구하는 것만 저장할 수 있어야 한다.

예를 들어, <1로 만들기>문제에서 처음에는 연산 결과를 저장해 나갔지만, 결국 필요한건 연산 횟수였다. 횟수만 저장하니 훨씬 빠르고 쉽게 풀 수 있었다. 저장할 변수를 잘못 설정하면 삽질을 하게 되고, 거의 시간초과 혹은 메모리 초과가 뜨게 된다..ㅠㅠ


### **1. RGB 거리(백준 1149번)**
![<백준 1149>](<C:\Users\KYE\Desktop\TIL\백준1149_rgb거리.JPG>)

**[풀이]**
이 문제도 비용의 최솟값을 구하는 문제이고, 최솟값을 구하는 과정에서 이전 단계의 연산 결과를 사용해야 하는 문제이다 --> DP 문제!

이 문제는 위, 아래 층과 색이 겹치면 안된다는 규칙이 있으므로, 최솟값을 구할 때 그 조건만 추가해 주면 된다.

나는 각 색깔에 따라서 조건을 세 가지로 구분했고, R에는 G, B 중 최솟값, G에는 R, B 중 최솟값.. 이런 식으로 구현하였다!

```python
n = int(input())
cost = [[0 for _ in range(3)] for _ in range(n)]

for i in range(n):
    cost[i] = list(map(int, input().split()))

for i in range(1, n):
    for j in range(3):
        if j == 0:
            cost[i][j] += min(cost[i-1][1], cost[i-1][2])
        elif j == 1:
            cost[i][j] += min(cost[i-1][0], cost[i-1][2])
        else:
            cost[i][j] += min(cost[i-1][0], cost[i-1][1])
        
result = min(cost[n-1])
print(result)
```

### **2. 정수 삼각형(백준 1932번)**
![<백준 1932>](<C:\Users\KYE\Desktop\TIL\백준1932_정수삼각형.JPG>)

**[풀이]**

이 문제도 최대값을 구하는 문제이고, 최대값을 구하는 과정에서 단계마다 최적 연산을 활용할 필요가 있는 문제이다 --> DP 문제!

i 번째 삼각형 리스트에는 i-1번째 대각선에 있는 두 수 중 합이 더 큰 결과만을 저장해야 하므로, 

>  triangle[i][j] += max(triangle[i-1][j-1], triangle[i-1][j])

이러한 식이 나온다. (일반적인 상황)

그런데, 이때 삼각형 모양에서 제일 왼쪽과 제일 오른쪽은 i-1번째에 대각선에 있는 수가 하나밖에 없으므로, 비교할 필요 없이 합을 저장하면 된다.

이렇게 삼각형 리스트 자체에 합한 결과를 저장해 놓았으므로, 삼각형의 n-1 번째 줄에는 각 경로의 합의 최댓값이 저장되어 있다. 이 중 가장 큰 수를 출력해주면 정답이다!

```python
n = int(input())
triangle = []
for _ in range(n):
    triangle.append(list(map(int, input().split()))) 

for i in range(1, n):
    for j in range(i+1):
        # 맨 앞에 있는 수 일때
        if j == 0: 
            triangle[i][j] += triangle[i-1][j]
        # 맨 뒤에 있는 수 일때
        elif j == i:
            triangle[i][j] += triangle[i-1][j-1]
        # 가운데 있는 수 일때(보통의 경우)
        else:
            triangle[i][j] += max(triangle[i-1][j-1], triangle[i-1][j])

result = max(triangle[n-1])
print(result)
```

### **3. 1로 만들기(백준 1463번)**

![<백준 1463>](<C:\Users\KYE\Desktop\TIL\백준1932_정수삼각형.JPG>)

**[풀이]**
처음에는 트리형태로 n에서부터 연산 결과를 저장해 내려오며, 연산 결과가 1이 되면 종료하게끔 코드를 짰다. 트리형태를 리스트로 구현하려니 2차원 리스트를 사용하였고, 이중 for문을 돌리게 되었다. 그러니 시간초과가 떴다..

생각해보니 연산 횟수만 구하면 되는데 연산 결과를 저장할 필요도 없었고(괜한 메모리만 차지하게 됨), n부터 계산을 해 나가면 연산 결과를 재활용 할 수도 없게 된다(연산 결과 재활용을 못하니 시간 부족).


다음으로 생각한 방법은 1에서 부터 n까지 필요한 연산 횟수를 저장하는 방법이었다. 이렇게 하면 1차원 배열에 연산 횟수만 저장할 수 있고, 저장해둔 연산 횟수를 재활용할 수 있다. 


예를 들어, dp[10]은 10에서 1을 만드는 데 필요한 최소 연산 횟수를 나타내는데, 10은 2로 나누기와 1 빼기 연산이 가능하므로 dp[10]에는 dp[5]+1과 dp[9]+1 중에 더 작은 수를 저장하면 된다. dp[5]와 dp[9]도 이전 연산 횟수를 재활용하여 구할 수 있고, 그 이전 연산도 계속해서 이전 연산 횟수를 재활용하여 구할 수 있다!


```python
n = int(input())
dp = [0]*(n+1)

for i in range(2, n+1):
    dp[i] = dp[i-1]+1
    if i%3 == 0:
        dp[i] = min(dp[i], dp[i//3]+1)
    if i%2 == 0:
        dp[i] = min(dp[i], dp[i//2]+1)

print(dp[n])

```

