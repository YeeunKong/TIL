# **Dynamic Programming(동적 계획법)**
- 다이나믹 프로그래밍은 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것이다. 
- 이는 반복되는 연산을 저장해두었다가 재활용하므로, 메모리 공간을 약간 더 사용하지만 연산 속도를 비약적으로 증가시킬 수 있다.   


## **DP의 사용 조건**
1) Overlapping Subproblems (중복되는 부분 문제)
2) Optimal Substructure (최적 부분 구조)

1) Overlapping Subproblems
- DP는 부분 문제의 결과를 저장하여 다시 계산하지 않는다는 장점이 있는데, 해당 부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능하니 부분 문제가 중복되는 않는 경우에는 사용할 수 없다. 
- 예) 이진 탐색은 특정 데이터의 위치를 정렬된 배열 내에서 찾아 반환하므로 재사용하지 않아 DP에 부적합하다. 반면, 피보나치 수열은 f(3), f(2), f(1)을 호출하는 동일한 부분 문제가 중복되어 나타나므로 이 값을 저장하여 재사용하는 DP에 적합하다.

2) Optimal Substructure
- 부분 문제의 최적 결과 값을 사용하여 전체 문제의 최적 결과를 낼 수 있는 경우를 말한다.  


## **DP 사용하기**
① DP로 풀 수 있는 문제인지 확인하기
   1) Overlapping Subproblems (중복되는 부분 문제)
   2) Optimal Substructure (최적 부분 구조)

② 문제의 변수 파악하기

③ 변수 간 관계식 만들기(점화식)

④ 메모하기 (memoization or tabulation)

⑤ 기저 상태 파악하기
- 가장 작은 문제의 상태를 알아야 한다. (예. 피보나치 수열의 f(0)=f(1)=1)

⑥ 구현하기
- Top-Down(재귀 사용) or Bottom-Up(반복문 사용)


## **구현 방법**
① Top-Down 방식
- 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식으로, 하향식이라고 부른다.
- 재귀 함수를 이용하여 다이나믹 프로그래밍 코드를 작성하는 방법이다.
- 재귀 함수를 이용하는 방법(메모이제이션)에서는 한 번 푼 문제는 그 결과를 저장해 놓았다가 나중에 동일한 문제를 풀어야 할 때 이미 저장한 값을 반환한다.
- 피보나치를 예를 들면, f(1), f(2), f(3)이 반복적으로 호출되니 이 값들을 저장해 놓았다가 반환하여 사용하면 된다.
- 그러나, 시스템 상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문에, 탑다운 방식보다는 보텀업 방식으로 구현할 것을 권장한다.
- 재귀 함수를 너무 많이 호출하면 ‘recursion depth’와 관련된 오류가 발생할 수 있는데, 이 경우 sys 라이브러리에 포함되어 있는 setrecursionlimit() 함수를 호출하여 재귀 제한을 완화할 수 있다. 
② Bottom-Up 방식
- 작은 문제부터 차근차근 답을 도출해나가 큰 문제를 해결하는 방식으로, 다이나믹 프로그래밍의 전형적인 형태이다.
- 단순히 반복문을 이용하여 코드를 작성하는 방법으로, 상향식이라고 부른다. 
- 결과 저장용 리스트를 ‘DP 테이블’이라고 부른다. (메모이제이션은 탑다운 방식에 국한되어 사용)

## **Divide and Conquer와 Dynamic Programming의 차이점**
- 공통점: 주어진 문제를 작게 쪼개서 하위 문제를 해결해나가며 궁극적으로 큰 문제 해결하는 점
- 차이점: 분할 정복은 분할된 하위 문제가 동일하게 중복이 일어나지 않는 경우에 쓰고, 동일한 중복이 일어나면 동적 프로그래밍을 쓴다는 점



참고)
- 이것이 코딩 테스트다 with python
- https://hongjw1938.tistory.com/47